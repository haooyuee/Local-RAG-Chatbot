{
    "question": [
        "What branch of theoretical computer science deals with broadly classifying computational problems by difficulty and class of relationship?",
        "What measure of a computational problem broadly defines the inherent difficulty of the solution?",
        "What two fields of theoretical computer science closely mirror computational complexity theory?",
        "What is the name given to the input string of a computational problem?",
        "By how many kilometers does the traveling salesman problem seek to classify a route between the 15 largest cities in Germany?",
        "In a computational problem, what can be described as a string over an alphabet?",
        "What kind of problems are one of the main topics studied in computational complexity theory?",
        "What kind of graph is an example of an input used in a decision problem?",
        "A function problem is an example of what?",
        "How can function problems typically be restated?",
        "What is a commonly used measurement used to determine the complexity of a computational problem?",
        "Whose thesis states that the solution to a problem is solvable with reasonable resources assuming it allows for a polynomial time algorithm?"
    ],
    "answer": [
        " Computational complexity theory is the branch of theoretical computer science that deals with broadly classifying computational problems by difficulty and class of relationship.",
        "  I don't know.",
        "  Analysis of algorithms and computability theory.",
        "  The input string of a computational problem is called a \"problem instance\".",
        "  I don't know the answer to your question. The passage doesn't provide enough context to determine the exact distance of the traveling salesman problem instance.",
        "  A string over an alphabet in a computational problem can be a binary string, representing an integer, or any other mathematical object that needs to be suitably encoded.",
        "  Computational complexity theory is a branch of theoretical computer science that focuses on classifying computational problems according to their inherent difficulty. Some of the main topics studied in computational complexity theory include:\nTime complexity: This refers to the amount of time required to solve a computational problem. Time complexity is often measured in terms of the size of the input, and it is a fundamental concept in computational complexity theory.\nSpace complexity: This refers to the amount of memory required to solve a computational problem. Space complexity is also measured in terms of the size of the input, and it is closely related to time complexity.\nPractical limits of computation: Computational complexity theory aims to determine the practical limits of computation, i.e., what problems can be solved efficiently and what problems are inherently difficult to solve.\nHierarchy theorems: These are mathematical theorems that describe the relationship between different classes of computational problems in terms of their time and space complexity. The most well-known hierarchy theorems are the P vs. NP problem and the P vs. ZP problem.\nPolynomial-time algorithms: These are algorithms that have a running time that is a polynomial function of the size of the input. Polynomial-time algorithms",
        "  You don't know the answer to this question because it depends on the specific decision problem being discussed. The answer will vary depending on the context and the specific problem being described.",
        "  A function problem is a problem that involves computing a function, rather than determining whether a statement is true or false. For example, the traveling salesman problem is a function problem because it involves computing the shortest path between a set of cities, rather than determining whether a statement is true or false. Another example of a function problem is the integer factorization problem, which involves computing the factors of an integer, rather than determining whether a statement is true or false.",
        " Function problems can typically be restated as decision problems. For example, the traveling salesman problem can be restated as a decision problem by asking whether there exists a path that visits all cities exactly once and returns to the starting city in a distance of at most n. Similarly, the integer factorization problem can be restated as a decision problem by asking whether there exists an integer x such that x is divisible by all integers from 1 to n.",
        "  The answer to this question is not provided in the given text. The text only mentions that the time required to solve a problem (or the space required, or any measure of complexity) is calculated as a function of the size of the instance. It does not mention any specific measurement used to determine the complexity of a computational problem. Therefore, the answer to the question is \"I don't know.\"",
        "  The thesis attributed to John H. Conway states that the solution to a problem is solvable with reasonable resources.\n\n\n"
    ],
    "contexts": [
        [
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "solved algorithmically. A computational problem can be viewed as an infinite collection of instances\ntogether with a solution for every instance. The input string for a computational problem is referred to as\na problem instance, and should not be confused with the problem itself. In computational complexity\ntheory, a problem refers to the abstract question to be solved. In contrast, an instance of this problem is",
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be"
        ],
        [
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "solved algorithmically. A computational problem can be viewed as an infinite collection of instances\ntogether with a solution for every instance. The input string for a computational problem is referred to as\na problem instance, and should not be confused with the problem itself. In computational complexity\ntheory, a problem refers to the abstract question to be solved. In contrast, an instance of this problem is",
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be"
        ],
        [
            "of processors (used in parallel computing). One of the roles of computational complexity theory is to\ndetermine the practical limits on what computers can and cannot do. Closely related fields in theoretical\ncomputer science are analysis of algorithms and computability theory. A key distinction between\nanalysis of algorithms and computational complexity theory is that the former is devoted to analyzing\nthe amount of resources needed by a particular algorithm to solve a problem, whereas the latter asks a",
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be"
        ],
        [
            "solved algorithmically. A computational problem can be viewed as an infinite collection of instances\ntogether with a solution for every instance. The input string for a computational problem is referred to as\na problem instance, and should not be confused with the problem itself. In computational complexity\ntheory, a problem refers to the abstract question to be solved. In contrast, an instance of this problem is",
            "a rather concrete utterance, which can serve as the input for a decision problem. For example, consider\nthe problem of primality testing. The instance is a number (e.g. 15) and the solution is \"yes\" if the\nnumber is prime and \"no\" otherwise (in this case \"no\"). Stated another way, the instance is a particular\ninput to the problem, and the solution is the output corresponding to the given input. To further highlight",
            "whose total length is at most 10 km. For this reason, complexity theory addresses computational\nproblems and not particular problem instances. When considering computational problems, a problem\ninstance is a string over an alphabet. Usually, the alphabet is taken to be the binary alphabet (i.e., the\nset {0,1}), and thus the strings are bitstrings. As in a real-world computer, mathematical objects other\nthan bitstrings must be suitably encoded. For example, integers can be represented in binary notation,"
        ],
        [
            "the difference between a problem and an instance, consider the following instance of the decision\nversion of the traveling salesman problem: Is there a route of at most 2000 kilometres passing through\nall of Germany's 15 largest cities? The quantitative answer to this particular problem instance is of little\nuse for solving other instances of the problem, such as asking for a round trip through all sites in Milan",
            "whose total length is at most 10 km. For this reason, complexity theory addresses computational\nproblems and not particular problem instances. When considering computational problems, a problem\ninstance is a string over an alphabet. Usually, the alphabet is taken to be the binary alphabet (i.e., the\nset {0,1}), and thus the strings are bitstrings. As in a real-world computer, mathematical objects other\nthan bitstrings must be suitably encoded. For example, integers can be represented in binary notation,",
            "practically relevant problems that are NP-complete. In 1972, Richard Karp took this idea a leap forward\nwith his landmark paper, \"Reducibility Among Combinatorial Problems\", in which he showed that 21\ndiverse combinatorial and graph theoretical problems, each infamous for its computational intractability,\nare NP-complete."
        ],
        [
            "whose total length is at most 10 km. For this reason, complexity theory addresses computational\nproblems and not particular problem instances. When considering computational problems, a problem\ninstance is a string over an alphabet. Usually, the alphabet is taken to be the binary alphabet (i.e., the\nset {0,1}), and thus the strings are bitstrings. As in a real-world computer, mathematical objects other\nthan bitstrings must be suitably encoded. For example, integers can be represented in binary notation,",
            "representing a computing machine\u2014anything from an advanced supercomputer to a mathematician\nwith a pencil and paper. It is believed that if a problem can be solved by an algorithm, there exists a\nTuring machine that solves the problem. Indeed, this is the statement of the Church\u2013Turing thesis.\nFurthermore, it is known that everything that can be computed on other models of computation known\nto us today, such as a RAM machine, Conway's Game of Life, cellular automata or any programming",
            "solved algorithmically. A computational problem can be viewed as an infinite collection of instances\ntogether with a solution for every instance. The input string for a computational problem is referred to as\na problem instance, and should not be confused with the problem itself. In computational complexity\ntheory, a problem refers to the abstract question to be solved. In contrast, an instance of this problem is"
        ],
        [
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "of processors (used in parallel computing). One of the roles of computational complexity theory is to\ndetermine the practical limits on what computers can and cannot do. Closely related fields in theoretical\ncomputer science are analysis of algorithms and computability theory. A key distinction between\nanalysis of algorithms and computational complexity theory is that the former is devoted to analyzing\nthe amount of resources needed by a particular algorithm to solve a problem, whereas the latter asks a",
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources"
        ],
        [
            "and graphs can be encoded directly via their adjacency matrices, or by encoding their adjacency lists in\nbinary. Decision problems are one of the central objects of study in computational complexity theory. A\ndecision problem is a special type of computational problem whose answer is either yes or no, or\nalternately either 1 or 0. A decision problem can be viewed as a formal language, where the members\nof the language are instances whose output is yes, and the non-members are those instances whose",
            "deciding whether the given graph is connected, or not. The formal language associated with this\ndecision problem is then the set of all connected graphs\u2014of course, to obtain a precise definition of this\nlanguage, one has to decide how graphs are encoded as binary strings. A function problem is a\ncomputational problem where a single output (of a total function) is expected for every input, but the\noutput is more complex than that of a decision problem, that is, it isn't just yes or no. Notable examples",
            "a rather concrete utterance, which can serve as the input for a decision problem. For example, consider\nthe problem of primality testing. The instance is a number (e.g. 15) and the solution is \"yes\" if the\nnumber is prime and \"no\" otherwise (in this case \"no\"). Stated another way, the instance is a particular\ninput to the problem, and the solution is the output corresponding to the given input. To further highlight"
        ],
        [
            "include the traveling salesman problem and the integer factorization problem. It is tempting to think that\nthe notion of function problems is much richer than the notion of decision problems. However, this is not\nreally the case, since function problems can be recast as decision problems. For example, the",
            "within time f(n), if the time required by M on each input of length n is at most f(n). A decision problem A\ncan be solved in time f(n) if there exists a Turing machine operating in time f(n) that solves the problem.\nSince complexity theory is interested in classifying problems based on their difficulty, one defines sets\nof problems based on some criteria. For instance, the set of problems solvable within time f(n) on a",
            "the informal notion of a problem being at least as difficult as another problem. For instance, if a problem\nX can be solved using an algorithm for Y, X is no more difficult than Y, and we say that X reduces to Y.\nThere are many different types of reductions, based on the method of reduction, such as Cook\nreductions, Karp reductions and Levin reductions, and the bound on the complexity of reductions, such\nas polynomial-time reductions or log-space reductions. The most commonly used reduction is a"
        ],
        [
            "include the traveling salesman problem and the integer factorization problem. It is tempting to think that\nthe notion of function problems is much richer than the notion of decision problems. However, this is not\nreally the case, since function problems can be recast as decision problems. For example, the",
            "within time f(n), if the time required by M on each input of length n is at most f(n). A decision problem A\ncan be solved in time f(n) if there exists a Turing machine operating in time f(n) that solves the problem.\nSince complexity theory is interested in classifying problems based on their difficulty, one defines sets\nof problems based on some criteria. For instance, the set of problems solvable within time f(n) on a",
            "not known if they are distinct or equal classes. Problems that can be solved in theory (e.g., given large\nbut finite time), but which in practice take too long for their solutions to be useful, are known as\nintractable problems. In complexity theory, problems that lack polynomial-time solutions are considered\nto be intractable for more than the smallest inputs. In fact, the Cobham\u2013Edmonds thesis states that\nonly those problems that can be solved in polynomial time can be feasibly computed on some"
        ],
        [
            "regarded as inherently difficult if its solution requires significant resources, whatever the algorithm\nused. The theory formalizes this intuition, by introducing mathematical models of computation to study\nthese problems and quantifying the amount of resources needed to solve them, such as time and\nstorage. Other complexity measures are also used, such as the amount of communication (used in\ncommunication complexity), the number of gates in a circuit (used in circuit complexity) and the number",
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "general, depend on the instance. In particular, larger instances will require more time to solve. Thus the\ntime required to solve a problem (or the space required, or any measure of complexity) is calculated as\na function of the size of the instance. This is usually taken to be the size of the input in bits. Complexity\ntheory is interested in how algorithms scale with an increase in the input size. For instance, in the"
        ],
        [
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be",
            "not known if they are distinct or equal classes. Problems that can be solved in theory (e.g., given large\nbut finite time), but which in practice take too long for their solutions to be useful, are known as\nintractable problems. In complexity theory, problems that lack polynomial-time solutions are considered\nto be intractable for more than the smallest inputs. In fact, the Cobham\u2013Edmonds thesis states that\nonly those problems that can be solved in polynomial time can be feasibly computed on some",
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources"
        ]
    ],
    "ground_truth": [
        "Computational complexity theory",
        "its solution requires significant resources",
        "analysis of algorithms and computability theory",
        "a problem instance",
        "2000",
        "a problem instance",
        "Decision problems",
        "arbitrary",
        "a computational problem",
        "as decision problems",
        "time",
        "Cobham's"
    ]
}