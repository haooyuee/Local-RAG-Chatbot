{
    "question": [
        "What is the problem attributed to defining if two finite graphs are isomorphic?",
        "What computational problem is commonly associated with prime factorization?",
        "What is the unproven assumption generally ascribed to the value of complexity classes?",
        "In what complexity class do complement problems of NP problems exist?",
        "What variable is associated with all problems solved within logarithmic space?",
        "Problems capable of theoretical solutions but consuming unreasonable time in practical application are known as what?",
        "What eponymous variation of arithmetic presents a decision problem not evidenced in P?",
        "What tactic did researchers employ to offset the former deficit of work surrounding the complexity of algorithmic problems?",
        "What paper is commonly considered the bellwether ushering in systematic studies computational complexity?",
        "Who provided a definition of linear bounded automata in 1960?",
        "What is the concrete choice typically assumed by most complexity-theoretic theorems?",
        "Who is responsible for axiomatic complexity theory?"
    ],
    "answer": [
        " I don't know the answer to this question as it is an open problem in complexity theory. The problem of determining whether two finite graphs are isomorphic is not known to be in P, NP-complete, or NP-intermediate.",
        "  The computational problem commonly associated with prime factorization is the integer factorization problem.",
        " The unproven assumption generally ascribed to the value of complexity classes is that the Cobham-Edmonds thesis is true. This thesis states that every problem in NP can be solved efficiently by a deterministic Turing machine. However, this assumption has not been proven or disproven, and it is still an open question in the field of theoretical computer science.",
        "  The complement problems of NP problems exist in co-NP.",
        "  The variable associated with all problems solved within logarithmic space is L.",
        "  The term \"intractable\" is used to describe problems that can be solved in theory but take too long to solve in practice. These problems are known as intractable problems.",
        "  I don't know the answer to this question. The statement you provided does not provide enough context to determine whether there is a decision problem that is not in P. Without additional information, it is impossible to say whether such a problem exists.",
        "  Researchers employed the tactic of using mathematical rigor to offset the former deficit of work surrounding the complexity of algorithmic problems.",
        " The paper commonly considered the bellwether ushering in systematic studies of computational complexity is \"On the Computational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns, published in 1965.",
        " John Myhill provided a definition of linear bounded automata in 1960.",
        " Most complexity-theoretic theorems assume that the input size is measured in bits.",
        "  Manuel Blum is responsible for axiomatic complexity theory."
    ],
    "contexts": [
        [
            "problem are examples of problems believed to be NP-intermediate. They are some of the very few NP\nproblems not known to be in P or to be NP-complete. The graph isomorphism problem is the\ncomputational problem of determining whether two finite graphs are isomorphic. An important unsolved\nproblem in complexity theory is whether the graph isomorphism problem is in P, NP-complete, or\nNP-intermediate. The answer is not known, but it is believed that the problem is at least not",
            "NP-complete. If graph isomorphism is NP-complete, the polynomial time hierarchy collapses to its\nsecond level. Since it is widely believed that the polynomial hierarchy does not collapse to any finite\nlevel, it is believed that graph isomorphism is not NP-complete. The best algorithm for this problem, due\nto Laszlo Babai and Eugene Luks has run time 2O(\u221a(n log(n))) for graphs with n vertices. The integer\nfactorization problem is the computational problem of determining the prime factorization of a given",
            "deciding whether the given graph is connected, or not. The formal language associated with this\ndecision problem is then the set of all connected graphs\u2014of course, to obtain a precise definition of this\nlanguage, one has to decide how graphs are encoded as binary strings. A function problem is a\ncomputational problem where a single output (of a total function) is expected for every input, but the\noutput is more complex than that of a decision problem, that is, it isn't just yes or no. Notable examples"
        ],
        [
            "NP-complete. If graph isomorphism is NP-complete, the polynomial time hierarchy collapses to its\nsecond level. Since it is widely believed that the polynomial hierarchy does not collapse to any finite\nlevel, it is believed that graph isomorphism is not NP-complete. The best algorithm for this problem, due\nto Laszlo Babai and Eugene Luks has run time 2O(\u221a(n log(n))) for graphs with n vertices. The integer\nfactorization problem is the computational problem of determining the prime factorization of a given",
            "factorization is the general number field sieve, which takes time O(e(64/9)1/3(n.log 2)1/3(log (n.log\n2))2/3) to factor an n-bit integer. However, the best known quantum algorithm for this problem, Shor's\nalgorithm, does run in polynomial time. Unfortunately, this fact doesn't say much about where the\nproblem lies with respect to non-quantum complexity classes. Many known complexity classes are\nsuspected to be unequal, but this has not been proved. For instance P \u2286 NP \u2286 PP \u2286 PSPACE, but it is",
            "integer. Phrased as a decision problem, it is the problem of deciding whether the input has a factor less\nthan k. No efficient integer factorization algorithm is known, and this fact forms the basis of several\nmodern cryptographic systems, such as the RSA algorithm. The integer factorization problem is in NP\nand in co-NP (and even in UP and co-UP). If the problem is NP-complete, the polynomial time\nhierarchy will collapse to its first level (i.e., NP will equal co-NP). The best known algorithm for integer"
        ],
        [
            "40, in big O notation one would write T(n) = O(n2). Of course, some complexity classes have\ncomplicated definitions that do not fit into this framework. Thus, a typical complexity class has a\ndefinition like the following: But bounding the computation time above by some concrete function f(n)\noften yields complexity classes that depend on the chosen machine model. For instance, the language\n{xx | x is any binary string} can be solved in linear time on a multi-tape Turing machine, but necessarily",
            "The complexity class P is often seen as a mathematical abstraction modeling those computational\ntasks that admit an efficient algorithm. This hypothesis is called the Cobham\u2013Edmonds thesis. The\ncomplexity class NP, on the other hand, contains many problems that people would like to solve\nefficiently, but for which no efficient algorithm is known, such as the Boolean satisfiability problem, the\nHamiltonian path problem and the vertex cover problem. Since deterministic Turing machines are",
            "important complexity classes can be defined by bounding the time or space used by the algorithm.\nSome important complexity classes of decision problems defined in this manner are the following:\nOther important complexity classes include BPP, ZPP and RP, which are defined using probabilistic\nTuring machines; AC and NC, which are defined using Boolean circuits; and BQP and QMA, which are\ndefined using quantum Turing machines. #P is an important complexity class of counting problems (not"
        ],
        [
            "possible that P = PSPACE. If P is not equal to NP, then P is not equal to PSPACE either. Since there\nare many known complexity classes between P and PSPACE, such as RP, BPP, PP, BQP, MA, PH,\netc., it is possible that all these complexity classes collapse to one class. Proving that any of these\nclasses are unequal would be a major breakthrough in complexity theory. Along the same lines, co-NP\nis the class containing the complement problems (i.e. problems with the yes/no answers reversed) of",
            "NP problems. It is believed that NP is not equal to co-NP; however, it has not yet been proven. It has\nbeen shown that if these two complexity classes are not equal then P is not equal to NP. Similarly, it is\nnot known if L (the set of all problems that can be solved in logarithmic space) is strictly contained in P\nor equal to P. Again, there are many complexity classes between the two, such as NL and NC, and it is",
            "commonly used. In particular, the set of problems that are hard for NP is the set of NP-hard problems. If\na problem X is in C and hard for C, then X is said to be complete for C. This means that X is the hardest\nproblem in C. (Since many problems could be equally hard, one might say that X is one of the hardest\nproblems in C.) Thus the class of NP-complete problems contains the most difficult problems in NP, in"
        ],
        [
            "NP problems. It is believed that NP is not equal to co-NP; however, it has not yet been proven. It has\nbeen shown that if these two complexity classes are not equal then P is not equal to NP. Similarly, it is\nnot known if L (the set of all problems that can be solved in logarithmic space) is strictly contained in P\nor equal to P. Again, there are many complexity classes between the two, such as NL and NC, and it is",
            "the informal notion of a problem being at least as difficult as another problem. For instance, if a problem\nX can be solved using an algorithm for Y, X is no more difficult than Y, and we say that X reduces to Y.\nThere are many different types of reductions, based on the method of reduction, such as Cook\nreductions, Karp reductions and Levin reductions, and the bound on the complexity of reductions, such\nas polynomial-time reductions or log-space reductions. The most commonly used reduction is a",
            "space is needed in order to increase the number of problems that can be solved. The time and space\nhierarchy theorems form the basis for most separation results of complexity classes. For instance, the\ntime hierarchy theorem tells us that P is strictly contained in EXPTIME, and the space hierarchy\ntheorem tells us that L is strictly contained in PSPACE. Many complexity classes are defined using the\nconcept of a reduction. A reduction is a transformation of one problem into another problem. It captures"
        ],
        [
            "not known if they are distinct or equal classes. Problems that can be solved in theory (e.g., given large\nbut finite time), but which in practice take too long for their solutions to be useful, are known as\nintractable problems. In complexity theory, problems that lack polynomial-time solutions are considered\nto be intractable for more than the smallest inputs. In fact, the Cobham\u2013Edmonds thesis states that\nonly those problems that can be solved in polynomial time can be feasibly computed on some",
            "computational device. Problems that are known to be intractable in this sense include those that are\nEXPTIME-hard. If NP is not the same as P, then the NP-complete problems are also intractable in this\nsense. To see why exponential-time algorithms might be unusable in practice, consider a program that\nmakes 2n operations before halting. For small n, say 100, and assuming for the sake of example that\nthe computer does 1012 operations each second, the program would run for about 4 1010 years, which",
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be"
        ],
        [
            "prediction in biology, and the ability to find formal proofs of pure mathematics theorems. The P versus\nNP problem is one of the Millennium Prize Problems proposed by the Clay Mathematics Institute. There\nis a US$1,000,000 prize for resolving the problem. It was shown by Ladner that if P \u2260 NP then there\nexist problems in NP that are neither in P nor NP-complete. Such problems are called NP-intermediate\nproblems. The graph isomorphism problem, the discrete logarithm problem and the integer factorization",
            "include the traveling salesman problem and the integer factorization problem. It is tempting to think that\nthe notion of function problems is much richer than the notion of decision problems. However, this is not\nreally the case, since function problems can be recast as decision problems. For example, the",
            "special non-deterministic Turing machines, it is easily observed that each problem in P is also member\nof the class NP. The question of whether P equals NP is one of the most important open questions in\ntheoretical computer science because of the wide implications of a solution. If the answer is yes, many\nimportant problems can be shown to have more efficient solutions. These include various types of\ninteger programming problems in operations research, many problems in logistics, protein structure"
        ],
        [
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources",
            "more general question about all possible algorithms that could be used to solve the same problem.\nMore precisely, it tries to classify problems that can or cannot be solved with appropriately restricted\nresources. In turn, imposing restrictions on the available resources is what distinguishes computational\ncomplexity from computability theory: the latter theory asks what kind of problems can, in principle, be",
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is"
        ],
        [
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources",
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is",
            "of processors (used in parallel computing). One of the roles of computational complexity theory is to\ndetermine the practical limits on what computers can and cannot do. Closely related fields in theoretical\ncomputer science are analysis of algorithms and computability theory. A key distinction between\nanalysis of algorithms and computational complexity theory is that the former is devoted to analyzing\nthe amount of resources needed by a particular algorithm to solve a problem, whereas the latter asks a"
        ],
        [
            "include John Myhill's definition of linear bounded automata (Myhill 1960), Raymond Smullyan's study of\nrudimentary sets (1961), as well as Hisao Yamada's paper on real-time computations (1962).\nSomewhat earlier, Boris Trakhtenbrot (1956), a pioneer in the field from the USSR, studied another\nspecific complexity measure. As he remembers: Even though some proofs of complexity-theoretic\ntheorems regularly assume some concrete choice of input encoding, one tries to keep the discussion",
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources",
            "abstract enough to be independent of the choice of encoding. This can be achieved by ensuring that\ndifferent representations can be transformed into each other efficiently. In 1967, Manuel Blum\ndeveloped an axiomatic complexity theory based on his axioms and proved an important result, the\nso-called, speed-up theorem. The field really began to flourish in 1971 when the US researcher\nStephen Cook and, working independently, Leonid Levin in the USSR, proved that there exist"
        ],
        [
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources",
            "general, depend on the instance. In particular, larger instances will require more time to solve. Thus the\ntime required to solve a problem (or the space required, or any measure of complexity) is calculated as\na function of the size of the instance. This is usually taken to be the size of the input in bits. Complexity\ntheory is interested in how algorithms scale with an increase in the input size. For instance, in the",
            "space is needed in order to increase the number of problems that can be solved. The time and space\nhierarchy theorems form the basis for most separation results of complexity classes. For instance, the\ntime hierarchy theorem tells us that P is strictly contained in EXPTIME, and the space hierarchy\ntheorem tells us that L is strictly contained in PSPACE. Many complexity classes are defined using the\nconcept of a reduction. A reduction is a transformation of one problem into another problem. It captures"
        ],
        [
            "abstract enough to be independent of the choice of encoding. This can be achieved by ensuring that\ndifferent representations can be transformed into each other efficiently. In 1967, Manuel Blum\ndeveloped an axiomatic complexity theory based on his axioms and proved an important result, the\nso-called, speed-up theorem. The field really began to flourish in 1971 when the US researcher\nStephen Cook and, working independently, Leonid Levin in the USSR, proved that there exist",
            "beginning of systematic studies in computational complexity is attributed to the seminal paper \"On the\nComputational Complexity of Algorithms\" by Juris Hartmanis and Richard Stearns (1965), which laid\nout the definitions of time and space complexity and proved the hierarchy theorems. Also, in 1965\nEdmonds defined a \"good\" algorithm as one with running time bounded by a polynomial of the input\nsize. Earlier papers studying problems solvable by Turing machines with specific bounded resources",
            "Computational complexity theory is a branch of the theory of computation in theoretical computer\nscience that focuses on classifying computational problems according to their inherent difficulty, and\nrelating those classes to each other. A computational problem is understood to be a task that is in\nprinciple amenable to being solved by a computer, which is equivalent to stating that the problem may\nbe solved by mechanical application of mathematical steps, such as an algorithm. A problem is"
        ]
    ],
    "ground_truth": [
        "graph isomorphism",
        "integer factorization",
        "unequal",
        "co-NP",
        "L",
        "intractable problems",
        "Presburger",
        "numerous foundations were laid out",
        "On the Computational Complexity of Algorithms",
        "John Myhill",
        "input encoding",
        "Manuel Blum"
    ]
}